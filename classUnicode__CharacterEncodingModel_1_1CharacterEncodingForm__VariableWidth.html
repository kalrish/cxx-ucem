<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>cxx-ucem: Unicode_CharacterEncodingModel::CharacterEncodingForm_VariableWidth&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cxx-ucem
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">C++ infrastructure for the Unicode Character Encoding Model</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>README</span></a></li>
      <li><a href="motivation.html"><span>Motivation</span></a></li>
      <li><a href="design.html"><span>Design</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="userdefexamples.html"><span>Examples</span></a></li>
      <li><a href="faq.html"><span>FAQ</span></a></li>
      <li><a href="license.html"><span>License</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceUnicode__CharacterEncodingModel.html">Unicode_CharacterEncodingModel</a></li><li class="navelem"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html">CharacterEncodingForm_VariableWidth</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Unicode_CharacterEncodingModel::CharacterEncodingForm_VariableWidth&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for variable width character encoding forms.  
 <a href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="character__encoding__form-variable__width_8hpp_source.html">character_encoding_form-variable_width.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Unicode_CharacterEncodingModel::CharacterEncodingForm_VariableWidth&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth__inherit__graph.svg" width="622" height="96"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Unicode_CharacterEncodingModel::CharacterEncodingForm_VariableWidth&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth__coll__graph.svg" width="622" height="96"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae5a52c29d6fccb9daf0e6b278016d8e5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a> = typename detail::select_uint_holding_up_to&lt; MaxSequenceLength &gt;::type</td></tr>
<tr class="memdesc:ae5a52c29d6fccb9daf0e6b278016d8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type capable of holding the length of any code unit sequence.  <a href="#ae5a52c29d6fccb9daf0e6b278016d8e5">More...</a><br /></td></tr>
<tr class="separator:ae5a52c29d6fccb9daf0e6b278016d8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8eef8d90233784ba4eb792f693c2d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e8eef8d90233784ba4eb792f693c2d5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#a3e8eef8d90233784ba4eb792f693c2d5">incomplete</a> = <a class="el" href="structUnicode__CharacterEncodingModel_1_1detail_1_1incomplete.html">detail::incomplete</a>&lt; <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a>, MaxSequenceLength, typename <a class="el" href="structUnicode__CharacterEncodingModel_1_1CharacterEncodingForm_1_1ill__formed.html">CharacterEncodingForm_VariableWidth::ill_formed</a> &gt;</td></tr>
<tr class="memdesc:a3e8eef8d90233784ba4eb792f693c2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when a code unit sequence is incomplete. <br /></td></tr>
<tr class="separator:a3e8eef8d90233784ba4eb792f693c2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860ecc3dc390857cf9f8240a523b8da1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a860ecc3dc390857cf9f8240a523b8da1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a860ecc3dc390857cf9f8240a523b8da1">nonnegative_integer</a> = typename detail::select_uint_holding_up_to&lt; Max &gt;::type</td></tr>
<tr class="memdesc:a860ecc3dc390857cf9f8240a523b8da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type capable of holding any of the nonnegative integers that the character encoding form maps. <br /></td></tr>
<tr class="separator:a860ecc3dc390857cf9f8240a523b8da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0eb432be637dfe18a7a95e7ba3ab79c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#ad0eb432be637dfe18a7a95e7ba3ab79c">code_unit</a> = typename detail::select_appropriate_code_unit&lt; detail::round_to_byte_multiple(CodeUnitWidth)&gt;::type</td></tr>
<tr class="memdesc:ad0eb432be637dfe18a7a95e7ba3ab79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type capable of holding any of the values that code units may take.  <a href="#ad0eb432be637dfe18a7a95e7ba3ab79c">More...</a><br /></td></tr>
<tr class="separator:ad0eb432be637dfe18a7a95e7ba3ab79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a57634c8e1f8f4bcc5ca4b488df789ea6"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a860ecc3dc390857cf9f8240a523b8da1">CharacterEncodingForm_VariableWidth::nonnegative_integer</a>, <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#a57634c8e1f8f4bcc5ca4b488df789ea6">decode</a> (const typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#ad0eb432be637dfe18a7a95e7ba3ab79c">CharacterEncodingForm_VariableWidth::code_unit</a> *read_cursor) noexcept(noexcept(Derived::_decode(read_cursor)))</td></tr>
<tr class="memdesc:a57634c8e1f8f4bcc5ca4b488df789ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a code unit sequence with error checking.  <a href="#a57634c8e1f8f4bcc5ca4b488df789ea6">More...</a><br /></td></tr>
<tr class="separator:a57634c8e1f8f4bcc5ca4b488df789ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0081022df0b7aaa7152f7e02af9b0a81"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a860ecc3dc390857cf9f8240a523b8da1">CharacterEncodingForm_VariableWidth::nonnegative_integer</a>, <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#a0081022df0b7aaa7152f7e02af9b0a81">decode_assuming_validity</a> (const typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#ad0eb432be637dfe18a7a95e7ba3ab79c">CharacterEncodingForm_VariableWidth::code_unit</a> *read_cursor) noexcept</td></tr>
<tr class="memdesc:a0081022df0b7aaa7152f7e02af9b0a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a code unit sequence assuming that it is valid.  <a href="#a0081022df0b7aaa7152f7e02af9b0a81">More...</a><br /></td></tr>
<tr class="separator:a0081022df0b7aaa7152f7e02af9b0a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480f9ab5689ef4fc7e9e85fdf3149d89"><td class="memItemLeft" align="right" valign="top">static constexpr std::tuple&lt; typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a860ecc3dc390857cf9f8240a523b8da1">CharacterEncodingForm_VariableWidth::nonnegative_integer</a>, <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#a480f9ab5689ef4fc7e9e85fdf3149d89">decode_constexpry</a> (const typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#ad0eb432be637dfe18a7a95e7ba3ab79c">CharacterEncodingForm_VariableWidth::code_unit</a> *read_cursor) noexcept</td></tr>
<tr class="memdesc:a480f9ab5689ef4fc7e9e85fdf3149d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a code unit sequence statically and assuming that it is valid.  <a href="#a480f9ab5689ef4fc7e9e85fdf3149d89">More...</a><br /></td></tr>
<tr class="separator:a480f9ab5689ef4fc7e9e85fdf3149d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2ab712d67099732858e59fb36b4a06"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a860ecc3dc390857cf9f8240a523b8da1">CharacterEncodingForm_VariableWidth::nonnegative_integer</a>, <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#aac2ab712d67099732858e59fb36b4a06">decode</a> (const typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#ad0eb432be637dfe18a7a95e7ba3ab79c">CharacterEncodingForm_VariableWidth::code_unit</a> *read_cursor, <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a> code_units_left)</td></tr>
<tr class="memdesc:aac2ab712d67099732858e59fb36b4a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a sequence of code units into a nonnegative integer with bounds checking.  <a href="#aac2ab712d67099732858e59fb36b4a06">More...</a><br /></td></tr>
<tr class="separator:aac2ab712d67099732858e59fb36b4a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c366542691c540e4250a9b58dd28db"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae6c366542691c540e4250a9b58dd28db">encoded_length</a> (typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a860ecc3dc390857cf9f8240a523b8da1">CharacterEncodingForm_VariableWidth::nonnegative_integer</a> i) noexcept</td></tr>
<tr class="memdesc:ae6c366542691c540e4250a9b58dd28db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the length of the code unit sequence corresponding to a nonnegative integer.  <a href="#ae6c366542691c540e4250a9b58dd28db">More...</a><br /></td></tr>
<tr class="separator:ae6c366542691c540e4250a9b58dd28db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bde84a1ef135aa6870c0d45423dca34"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#a4bde84a1ef135aa6870c0d45423dca34">encoded_length_constexpry</a> (typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a860ecc3dc390857cf9f8240a523b8da1">CharacterEncodingForm_VariableWidth::nonnegative_integer</a> i) noexcept</td></tr>
<tr class="memdesc:a4bde84a1ef135aa6870c0d45423dca34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the length of the code unit sequence corresponding to a nonnegative integer.  <a href="#a4bde84a1ef135aa6870c0d45423dca34">More...</a><br /></td></tr>
<tr class="separator:a4bde84a1ef135aa6870c0d45423dca34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774ae3cab51ebdaedb101b45accdada8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#a774ae3cab51ebdaedb101b45accdada8">encode</a> (typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a860ecc3dc390857cf9f8240a523b8da1">CharacterEncodingForm_VariableWidth::nonnegative_integer</a> i, typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#ad0eb432be637dfe18a7a95e7ba3ab79c">CharacterEncodingForm_VariableWidth::code_unit</a> *out) noexcept</td></tr>
<tr class="memdesc:a774ae3cab51ebdaedb101b45accdada8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a nonnegative integer into a sequence of code units.  <a href="#a774ae3cab51ebdaedb101b45accdada8">More...</a><br /></td></tr>
<tr class="separator:a774ae3cab51ebdaedb101b45accdada8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507d2dff779db43b81d22a690e9d756e"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#a507d2dff779db43b81d22a690e9d756e">encode_constexpry</a> (typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a860ecc3dc390857cf9f8240a523b8da1">CharacterEncodingForm_VariableWidth::nonnegative_integer</a> i, typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#ad0eb432be637dfe18a7a95e7ba3ab79c">CharacterEncodingForm_VariableWidth::code_unit</a> *out) noexcept</td></tr>
<tr class="memdesc:a507d2dff779db43b81d22a690e9d756e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a nonnegative integer into a sequence of code units.  <a href="#a507d2dff779db43b81d22a690e9d756e">More...</a><br /></td></tr>
<tr class="separator:a507d2dff779db43b81d22a690e9d756e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442985a60dad65ab8e82007450297414"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a442985a60dad65ab8e82007450297414">maps</a> (<a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a860ecc3dc390857cf9f8240a523b8da1">nonnegative_integer</a> i) noexcept</td></tr>
<tr class="memdesc:a442985a60dad65ab8e82007450297414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the character encoding form maps a nonnegative integer to a character.  <a href="#a442985a60dad65ab8e82007450297414">More...</a><br /></td></tr>
<tr class="separator:a442985a60dad65ab8e82007450297414"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af5ee91525150e7f60f46e6cc68ea8151"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5ee91525150e7f60f46e6cc68ea8151"></a>
static constexpr <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#af5ee91525150e7f60f46e6cc68ea8151">min_sequence_length</a> = MinSequenceLength</td></tr>
<tr class="memdesc:af5ee91525150e7f60f46e6cc68ea8151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum length of code unit sequences mapped by the character encoding form. <br /></td></tr>
<tr class="separator:af5ee91525150e7f60f46e6cc68ea8151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abe38e2d8079ccbf2785a44f0f6859d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5abe38e2d8079ccbf2785a44f0f6859d"></a>
static constexpr <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#a5abe38e2d8079ccbf2785a44f0f6859d">max_sequence_length</a> = MaxSequenceLength</td></tr>
<tr class="memdesc:a5abe38e2d8079ccbf2785a44f0f6859d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of code unit sequences mapped by the character encoding form. <br /></td></tr>
<tr class="separator:a5abe38e2d8079ccbf2785a44f0f6859d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54531e2fa1301168d4f88c68f6f8fbea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54531e2fa1301168d4f88c68f6f8fbea"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a54531e2fa1301168d4f88c68f6f8fbea">code_unit_width</a> = CodeUnitWidth</td></tr>
<tr class="memdesc:a54531e2fa1301168d4f88c68f6f8fbea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary width occupied by each code unit. <br /></td></tr>
<tr class="separator:a54531e2fa1301168d4f88c68f6f8fbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f707e67c430aaa04f0026146423c17"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a56f707e67c430aaa04f0026146423c17">smallest_mapped_nonnegative_integer</a> = Min</td></tr>
<tr class="memdesc:a56f707e67c430aaa04f0026146423c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum nonnegative integer that the coded character set maps.  <a href="#a56f707e67c430aaa04f0026146423c17">More...</a><br /></td></tr>
<tr class="separator:a56f707e67c430aaa04f0026146423c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf50dc96d849c8ed09915af5e4973f2"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#afbf50dc96d849c8ed09915af5e4973f2">greatest_mapped_nonnegative_integer</a> = Max</td></tr>
<tr class="memdesc:afbf50dc96d849c8ed09915af5e4973f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum nonnegative integer that the coded character set maps.  <a href="#afbf50dc96d849c8ed09915af5e4973f2">More...</a><br /></td></tr>
<tr class="separator:afbf50dc96d849c8ed09915af5e4973f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Derived, unsigned long long Min, unsigned long long Max, std::size_t CodeUnitWidth, std::size_t MinSequenceLength, std::size_t MaxSequenceLength&gt;<br />
class Unicode_CharacterEncodingModel::CharacterEncodingForm_VariableWidth&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;</h3>

<p>Base class for variable width character encoding forms. </p>
<p>Variable width character encoding form implementations should derive from this class.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>The class that derives from this class. </td></tr>
    <tr><td class="paramname">Min</td><td>The minimum nonnegative integer that the character encoding form maps. </td></tr>
    <tr><td class="paramname">Max</td><td>The maximum nonnegative integer that the character encoding form maps. </td></tr>
    <tr><td class="paramname">CodeUnitWidth</td><td>The binary width occupied by each code unit. </td></tr>
    <tr><td class="paramname">MaxSequenceLength</td><td>The maximum number of code units a single code point may be mapped to. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ad0eb432be637dfe18a7a95e7ba3ab79c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Derived , unsigned long long Min, unsigned long long Max, std::size_t CodeUnitWidth&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html">Unicode_CharacterEncodingModel::CharacterEncodingForm</a>&lt; Derived, Min, Max, CodeUnitWidth &gt;::<a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#ad0eb432be637dfe18a7a95e7ba3ab79c">code_unit</a> =  typename detail::select_appropriate_code_unit&lt;detail::round_to_byte_multiple(CodeUnitWidth)&gt;::type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsigned integer type capable of holding any of the values that code units may take. </p>
<dl class="section note"><dt>Note</dt><dd>This type might be capable of holding values not handled by the character encoding form. For example, on a system where bytes are 8-bit wide, a character encoding form that worked with code units 7-bit wide would get a type with at least 8 bits. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5a52c29d6fccb9daf0e6b278016d8e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Derived , unsigned long long Min, unsigned long long Max, std::size_t CodeUnitWidth, std::size_t MinSequenceLength, std::size_t MaxSequenceLength&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html">Unicode_CharacterEncodingModel::CharacterEncodingForm_VariableWidth</a>&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;::<a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a> =  typename detail::select_uint_holding_up_to&lt;MaxSequenceLength&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integer type capable of holding the length of any code unit sequence. </p>
<p>This type is used to represent the length of sequences of code units. units. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a57634c8e1f8f4bcc5ca4b488df789ea6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Derived , unsigned long long Min, unsigned long long Max, std::size_t CodeUnitWidth, std::size_t MinSequenceLength, std::size_t MaxSequenceLength&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple&lt; typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a860ecc3dc390857cf9f8240a523b8da1">CharacterEncodingForm_VariableWidth::nonnegative_integer</a>, <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a> &gt; <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html">Unicode_CharacterEncodingModel::CharacterEncodingForm_VariableWidth</a>&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;::decode </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html">CharacterEncodingForm_VariableWidth</a>&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;::<a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#ad0eb432be637dfe18a7a95e7ba3ab79c">code_unit</a> *&#160;</td>
          <td class="paramname"><em>read_cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode a code unit sequence with error checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">read_cursor</td><td>A pointer pointing to a sequence of enough code units.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a href="http://en.cppreference.com/w/cpp/utility/tuple"><code>std::tuple</code></a> whose first element is the decoded nonnegative integer and whose second element is the number of code units consumed in the operation.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The helper <a href="http://en.cppreference.com/w/cpp/utility/tuple/tie"><code>std::tie</code></a> can make working with the return values easier.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;tuple&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;</div><div class="line"> <span class="keyword">class </span>VWCEF <span class="comment">/* a variable-width character encoding form */</span></div><div class="line">&gt;</div><div class="line"><span class="keywordtype">void</span> decode_a_single_nonnegative_integer</div><div class="line">(</div><div class="line"> <span class="keyword">const</span> <span class="keyword">typename</span> VWCEF::code_unit * code_units <span class="comment">/* pointing to a series of code units */</span></div><div class="line">)</div><div class="line">{</div><div class="line">    <span class="keyword">typename</span> VWCEF::nonnegative_integer nni;</div><div class="line">    <span class="keyword">typename</span> VWCEF::sequence_length how_many_code_units_were_decoded;</div><div class="line"></div><div class="line">    std::tie( nni , how_many_code_units_were_decoded ) = VWCEF::decode( code_units );</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aac2ab712d67099732858e59fb36b4a06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Derived , unsigned long long Min, unsigned long long Max, std::size_t CodeUnitWidth, std::size_t MinSequenceLength, std::size_t MaxSequenceLength&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple&lt; typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a860ecc3dc390857cf9f8240a523b8da1">CharacterEncodingForm_VariableWidth::nonnegative_integer</a>, <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a> &gt; <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html">Unicode_CharacterEncodingModel::CharacterEncodingForm_VariableWidth</a>&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;::decode </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html">CharacterEncodingForm_VariableWidth</a>&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;::<a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#ad0eb432be637dfe18a7a95e7ba3ab79c">code_unit</a> *&#160;</td>
          <td class="paramname"><em>read_cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a>&#160;</td>
          <td class="paramname"><em>code_units_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode a sequence of code units into a nonnegative integer with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">read_cursor</td><td>A pointer pointing to a sequence of code units. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code_units_left</td><td>How many code units are available for reading.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#a3e8eef8d90233784ba4eb792f693c2d5" title="Thrown when a code unit sequence is incomplete. ">incomplete</a></td><td>If not enough code units are supplied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a href="http://en.cppreference.com/w/cpp/utility/tuple"><code>std::tuple</code></a> whose first element is the decoded nonnegative integer and whose second element is the number of code units consumed in the operation.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The helper <a href="http://en.cppreference.com/w/cpp/utility/tuple/tie"><code>std::tie</code></a> can make working with the return values easier. </dd></dl>

</div>
</div>
<a class="anchor" id="a0081022df0b7aaa7152f7e02af9b0a81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Derived , unsigned long long Min, unsigned long long Max, std::size_t CodeUnitWidth, std::size_t MinSequenceLength, std::size_t MaxSequenceLength&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple&lt; typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a860ecc3dc390857cf9f8240a523b8da1">CharacterEncodingForm_VariableWidth::nonnegative_integer</a>, <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a> &gt; <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html">Unicode_CharacterEncodingModel::CharacterEncodingForm_VariableWidth</a>&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;::decode_assuming_validity </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html">CharacterEncodingForm_VariableWidth</a>&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;::<a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#ad0eb432be637dfe18a7a95e7ba3ab79c">code_unit</a> *&#160;</td>
          <td class="paramname"><em>read_cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode a code unit sequence assuming that it is valid. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method assumes input to be valid.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">read_cursor</td><td>A pointer pointing to a sequence of enough code units.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a href="http://en.cppreference.com/w/cpp/utility/tuple"><code>std::tuple</code></a> whose first element is the decoded nonnegative integer and whose second element is the number of code units consumed in the operation.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The helper <a href="http://en.cppreference.com/w/cpp/utility/tuple/tie"><code>std::tie</code></a> can make working with the return values easier. </dd></dl>

</div>
</div>
<a class="anchor" id="a480f9ab5689ef4fc7e9e85fdf3149d89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Derived , unsigned long long Min, unsigned long long Max, std::size_t CodeUnitWidth, std::size_t MinSequenceLength, std::size_t MaxSequenceLength&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::tuple&lt; typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a860ecc3dc390857cf9f8240a523b8da1">CharacterEncodingForm_VariableWidth::nonnegative_integer</a>, <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a> &gt; <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html">Unicode_CharacterEncodingModel::CharacterEncodingForm_VariableWidth</a>&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;::decode_constexpry </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html">CharacterEncodingForm_VariableWidth</a>&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;::<a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#ad0eb432be637dfe18a7a95e7ba3ab79c">code_unit</a> *&#160;</td>
          <td class="paramname"><em>read_cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode a code unit sequence statically and assuming that it is valid. </p>
<dl class="section attention"><dt>Attention</dt><dd>This method is not meant to be used at runtime. It lacks error checking and could be very slow.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method assumes input to be valid.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">read_cursor</td><td>A pointer pointing to a sequence of enough code units.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a href="http://en.cppreference.com/w/cpp/utility/tuple"><code>std::tuple</code></a> whose first element is the decoded nonnegative integer and whose second element is the number of code units consumed in the operation.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The helper <a href="http://en.cppreference.com/w/cpp/utility/tuple/tie"><code>std::tie</code></a> can make working with the return values easier. </dd></dl>

</div>
</div>
<a class="anchor" id="a774ae3cab51ebdaedb101b45accdada8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Derived , unsigned long long Min, unsigned long long Max, std::size_t CodeUnitWidth, std::size_t MinSequenceLength, std::size_t MaxSequenceLength&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a> <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html">Unicode_CharacterEncodingModel::CharacterEncodingForm_VariableWidth</a>&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;::encode </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html">CharacterEncodingForm_VariableWidth</a>&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;::<a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a860ecc3dc390857cf9f8240a523b8da1">nonnegative_integer</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html">CharacterEncodingForm_VariableWidth</a>&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;::<a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#ad0eb432be637dfe18a7a95e7ba3ab79c">code_unit</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode a nonnegative integer into a sequence of code units. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The nonnegative integer to encode. It must be mapped by the character encoding form. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>A pointer pointing to an output buffer of code units with size equal to or greater than the number of code units the given code point is encoded in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Pre-allocating a buffer big enough to hold the number of code units of the longest sequence mapped by the character encoding form (<a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#a5abe38e2d8079ccbf2785a44f0f6859d" title="Maximum length of code unit sequences mapped by the character encoding form. ">max_sequence_length</a>) is more efficient than computing the length of the code unit sequence that corresponds to each of the nonnegative integers to be encoded. Moreover, that way the array may be allocated on the stack with ease.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>How many code units the given code point was encoded in. </dd></dl>

</div>
</div>
<a class="anchor" id="a507d2dff779db43b81d22a690e9d756e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Derived , unsigned long long Min, unsigned long long Max, std::size_t CodeUnitWidth, std::size_t MinSequenceLength, std::size_t MaxSequenceLength&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a> <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html">Unicode_CharacterEncodingModel::CharacterEncodingForm_VariableWidth</a>&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;::encode_constexpry </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html">CharacterEncodingForm_VariableWidth</a>&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;::<a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a860ecc3dc390857cf9f8240a523b8da1">nonnegative_integer</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html">CharacterEncodingForm_VariableWidth</a>&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;::<a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#ad0eb432be637dfe18a7a95e7ba3ab79c">code_unit</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode a nonnegative integer into a sequence of code units. </p>
<dl class="section attention"><dt>Attention</dt><dd>This method is not meant to be used at runtime. It lacks error checking and could be very slow.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The nonnegative integer to encode. It must be mapped by the character encoding form. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>A pointer pointing to an output buffer of code units with size equal to or greater than the number of code units the given code point is encoded in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>How many code units the given code point was encoded in. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6c366542691c540e4250a9b58dd28db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Derived , unsigned long long Min, unsigned long long Max, std::size_t CodeUnitWidth, std::size_t MinSequenceLength, std::size_t MaxSequenceLength&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a> <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html">Unicode_CharacterEncodingModel::CharacterEncodingForm_VariableWidth</a>&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;::encoded_length </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html">CharacterEncodingForm_VariableWidth</a>&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;::<a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a860ecc3dc390857cf9f8240a523b8da1">nonnegative_integer</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the length of the code unit sequence corresponding to a nonnegative integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The nonnegative integer to check. It must be mapped by the character encoding form.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>How many code units the given nonnegative integer would be encoded in. </dd></dl>

</div>
</div>
<a class="anchor" id="a4bde84a1ef135aa6870c0d45423dca34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Derived , unsigned long long Min, unsigned long long Max, std::size_t CodeUnitWidth, std::size_t MinSequenceLength, std::size_t MaxSequenceLength&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html#ae5a52c29d6fccb9daf0e6b278016d8e5">sequence_length</a> <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html">Unicode_CharacterEncodingModel::CharacterEncodingForm_VariableWidth</a>&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;::encoded_length_constexpry </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm__VariableWidth.html">CharacterEncodingForm_VariableWidth</a>&lt; Derived, Min, Max, CodeUnitWidth, MinSequenceLength, MaxSequenceLength &gt;::<a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a860ecc3dc390857cf9f8240a523b8da1">nonnegative_integer</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the length of the code unit sequence corresponding to a nonnegative integer. </p>
<dl class="section attention"><dt>Attention</dt><dd>This method is not meant to be used at runtime. It lacks error checking and could be very slow.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The nonnegative integer to check. It must be mapped by the character encoding form.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>How many code units the given nonnegative integer would be encoded in. </dd></dl>

</div>
</div>
<a class="anchor" id="a442985a60dad65ab8e82007450297414"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Derived , unsigned long long Min, unsigned long long Max, std::size_t CodeUnitWidth&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html">Unicode_CharacterEncodingModel::CharacterEncodingForm</a>&lt; Derived, Min, Max, CodeUnitWidth &gt;::maps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a860ecc3dc390857cf9f8240a523b8da1">nonnegative_integer</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the character encoding form maps a nonnegative integer to a character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The nonnegative integer to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the character encoding form maps the given nonnegative integer; <code>false</code> otherwise. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="afbf50dc96d849c8ed09915af5e4973f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Derived , unsigned long long Min, unsigned long long Max, std::size_t CodeUnitWidth&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html">Unicode_CharacterEncodingModel::CharacterEncodingForm</a>&lt; Derived, Min, Max, CodeUnitWidth &gt;::greatest_mapped_nonnegative_integer = Max</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum nonnegative integer that the coded character set maps. </p>
<dl class="section attention"><dt>Attention</dt><dd>The set of nonnegative integers mapped by a character encoding form may not be a contiguous range. Therefore, it would be wrong to check whether a nonnegative integer is mapped by a character encoding form by checking whether it is greater than or equal to the minimum value mapped and equal to or less than the maximum value mapped; instead, use <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a442985a60dad65ab8e82007450297414" title="Check whether the character encoding form maps a nonnegative integer to a character. ">maps</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a56f707e67c430aaa04f0026146423c17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Derived , unsigned long long Min, unsigned long long Max, std::size_t CodeUnitWidth&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html">Unicode_CharacterEncodingModel::CharacterEncodingForm</a>&lt; Derived, Min, Max, CodeUnitWidth &gt;::smallest_mapped_nonnegative_integer = Min</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum nonnegative integer that the coded character set maps. </p>
<dl class="section attention"><dt>Attention</dt><dd>The set of nonnegative integers mapped by a character encoding form may not be a contiguous range. Therefore, it would be wrong to check whether a nonnegative integer is mapped by a character encoding form by checking whether it is greater than or equal to the minimum value mapped and equal to or less than the maximum value mapped; instead, use <a class="el" href="classUnicode__CharacterEncodingModel_1_1CharacterEncodingForm.html#a442985a60dad65ab8e82007450297414" title="Check whether the character encoding form maps a nonnegative integer to a character. ">maps</a>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="character__encoding__form-variable__width_8hpp_source.html">character_encoding_form-variable_width.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
